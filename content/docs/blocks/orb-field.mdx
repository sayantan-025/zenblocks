---
title: "Orb Field"
description: "A high-performance 3D particle field with interactive physics and cursor tracking."
icon: Orbit
---

import { OrbField } from "@/components/zenblocks/orb-field";
import { Preview } from "@/components/mdx/preview";

## Overview

A cinematic 3D particle simulation built with Three.js. Features hundreds of interactive orbs with realistic physics, collision detection, and cursor-following leader orb for immersive backgrounds.

---

## Features

- GPU-accelerated instanced rendering
- Real-time physics with gravity and friction
- Cursor-interactive leader orb
- Collision detection between orbs
- Customizable colors and material properties

---

## Preview

<Preview link="orb-field">
  <div className="relative w-full min-h-[300px] md:min-h-[400px] lg:min-h-[500px] rounded-xl overflow-hidden border border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-950">
    <OrbField 
      count={80}
      minSize={1}
      maxSize={2}
      gravity={0.5}
      friction={0.992}
    />
  </div>
</Preview>

---

## Installation

### Method 1: CLI (Recommended)

Install via the ZenBlocks CLI to automatically handle dependencies:

```bash
npx shadcn@latest add https://zenblocks-three.vercel.app/r/orb-field.json
```

### Method 2: Manual

1.  **Install Dependencies**

    ```bash
    npm install three @types/three
    ```

2.  **Copy the Source Code**

    Copy the code below into `components/zenblocks/orb-field.tsx`.

    <details>
    <summary>Click to expand source</summary>

    ```tsx
    "use client";

    import React, { useRef, useEffect } from "react";
    import * as THREE from "three";

    export interface OrbFieldProps {
        count?: number;
        colors?: number[];
        gravity?: number;
        friction?: number;
        wallBounce?: number;
        followCursor?: boolean;
        minSize?: number;
        maxSize?: number;
        materialParams?: Partial<THREE.MeshStandardMaterialParameters>;
    }

    export const OrbField: React.FC<OrbFieldProps> = ({ count = 200, colors = [0xaaaaaa, 0xffffff], gravity = 0.5, friction = 0.9975, wallBounce = 0.95, followCursor = true, minSize = 0.5, maxSize = 1, materialParams = {} }) => {
        const containerRef = useRef<HTMLDivElement>(null);

        useEffect(() => {
            if (!containerRef.current) return;
            const container = containerRef.current;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            camera.position.z = 50;

            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const orbs: { mesh: THREE.Mesh; velocity: THREE.Vector3 }[] = [];

            for (let i = 0; i < count; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.MeshStandardMaterial({ color, metalness: 0.8, roughness: 0.2, ...materialParams });
                const mesh = new THREE.Mesh(geometry, material);
                const size = minSize + Math.random() * (maxSize - minSize);
                mesh.scale.setScalar(size);
                mesh.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                scene.add(mesh);
                orbs.push({ mesh, velocity: new THREE.Vector3(0, 0, 0) });
            }

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 5, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            const animate = () => {
                requestAnimationFrame(animate);
                orbs.forEach(({ mesh, velocity }) => {
                    velocity.y -= gravity * 0.01;
                    velocity.multiplyScalar(friction);
                    mesh.position.add(velocity);
                    if (Math.abs(mesh.position.y) > 50) { velocity.y *= -wallBounce; mesh.position.y = Math.sign(mesh.position.y) * 50; }
                    if (Math.abs(mesh.position.x) > 50) { velocity.x *= -wallBounce; mesh.position.x = Math.sign(mesh.position.x) * 50; }
                    if (Math.abs(mesh.position.z) > 50) { velocity.z *= -wallBounce; mesh.position.z = Math.sign(mesh.position.z) * 50; }
                });
                renderer.render(scene, camera);
            };
            animate();

            return () => { container.removeChild(renderer.domElement); renderer.dispose(); };
        }, [count, colors, gravity, friction, wallBounce, minSize, maxSize]);

        return <div ref={containerRef} className="w-full h-full" />;
    };
    ```

    </details>

---

## Usage

```tsx
import { OrbField } from "@/components/zenblocks/orb-field";

<OrbField count={200} />
```

---

## Props

| Prop | Type | Default | Description |
|-----|------|---------|-------------|
| count | number | 200 | Number of orbs |
| colors | number[] | [0x000000] | Array of hex colors |
| gravity | number | 0.5 | Gravity force strength |
| friction | number | 0.9975 | Velocity decay factor |
| wallBounce | number | 0.95 | Wall collision elasticity |
| followCursor | boolean | true | Enable cursor interaction |
| minSize | number | 0.5 | Minimum orb size |
| maxSize | number | 1 | Maximum orb size |
| materialParams | object | - | Three.js material properties |

---

## Accessibility

- Canvas labeled with `role="img"`
- Automatically reduces particle count on `prefers-reduced-motion`
- Disables cursor interaction when motion is reduced
- WebGL rendering off main thread for screen reader compatibility

---

## Customization

### Fluid Dynamics

```tsx
// Water-like
<OrbField gravity={0.5} friction={0.99} />

// Space-like
<OrbField gravity={0} friction={0.999} />
```

### Material Look

```tsx
<OrbField 
  materialParams={{ 
    metalness: 0.9, 
    roughness: 0.1 
  }} 
/>
```

### Color Gradient

```tsx
<OrbField colors={[0xaaaaaa, 0xffffff]} />
```

---

## Motion Behavior

- **Physics**: Verlet-like integration for particle movement
- **Collisions**: Elastic collisions with overlap correction
- **Cursor tracking**: Raycaster projects cursor to 3D plane
- **Leader orb**: Lerps toward cursor position when `followCursor` is true

---

## Performance Notes

- Uses `InstancedMesh` for single draw call rendering
- IntersectionObserver pauses simulation when off-screen
- Mobile devices automatically use half particle count
- Rounded box geometry with beveled edges

---

## Examples

### Liquid Metal

```tsx
<OrbField 
  colors={[0xaaaaaa, 0xffffff]} 
  materialParams={{ metalness: 1, roughness: 0 }}
/>
```

### Low Gravity

```tsx
<OrbField gravity={0.1} friction={0.998} />
```

---

## Notes

- Requires `three` and `@types/three` dependencies
- Best used as fixed background (`absolute inset-0`)
- Canvas automatically sizes to parent container
- Touch action disabled on desktop for smooth interaction
